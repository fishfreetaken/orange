1 搞了两天的rsa，有一个大大的坑，终于在某个网站看到解决方案了，就是在传入的加密字符太长了：
“
不用 google ， man RSA_public_encrypt 即可。
RSA_PKCS1_PADDING 模式下，明文长度 < rsa_len - 1
”
说明啥：在加密的时候一定要预留出来一定的空间，传入的char的长度要小于开辟的长度，否则总是会报出一大堆错误。
例如：   140241510639520:error:0406D06E:lib(4):func(109):reason(110):rsa_pk1.c:151
        139937856018336:error:0407906E:lib(4):func(121):reason(110):rsa_oaep.c:45:
        补充 2019-07-04 这个原因是由于RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE，也就是说对于能加密的字符长度有限制，一般是（输出密文长度-21*2）


2 2019-07-04 由于 RSA_free(rsa);提前释放了rsa，导致后边进行压缩时候，找不到句柄，导致程序coredump

3 2019-07-08 起了八个进程，只有五个能accept连接上，为啥？ accept 的fd设置为阻塞方式了，只要设置为非阻塞就可以了。

4 2019-07-09 string的字符串赋值，string.assign()加第二个参数len，导致由于字符中包含'\0'，随机产生的aes的key256个字节，没有全部被用来赋值（由于'\0'的截断），因此一定要指定使用多少个字节进行初始化。

5 2019-07-09 accept使用了et模式，但是接收连接的时候，一次事件只处理一个连接，导致其他连接没没有被accept，et模式只通知一次，一定要使用while进行处理。

6 2019-07-10 如果发现有哪里class内的变量被改变了，肯定哪个写内存越界了，重要的事情说三遍！
7 2019-07-12 MD 为毛断链重新连接后，会多出来两个包解密不了，从哪里来的数据，后来又恢复正常了。
8 2019-07-13 由于发送端使用了队列，将原加密后的消息push入队列中，重新建立连接后，使用了新的aes密码，导致原来的加密后的消息不能发送出去。(事实好像不是这个情况！还是存在 ，我把发送的放在了后面解决了)

